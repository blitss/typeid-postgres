/* <begin connected objects> */
/*
This file is auto generated by pgrx.

The ordering of items is not stable, it is driven by a dependency graph.
*/
/* </end connected objects> */

/* <begin connected objects> */
-- src/typeid.rs:107
-- typeid::typeid::TypeID
CREATE TYPE TypeID;

-- src/typeid.rs:107
-- typeid::typeid::typeid_in
CREATE  FUNCTION "typeid_in"(
        "input" cstring /* core::option::Option<&core::ffi::c_str::CStr> */
) RETURNS TypeID /* core::option::Option<typeid::typeid::TypeID> */
IMMUTABLE PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'typeid_in_wrapper';

-- src/typeid.rs:107
-- typeid::typeid::typeid_out
CREATE  FUNCTION "typeid_out"(
        "input" TypeID /* typeid::typeid::TypeID */
) RETURNS cstring /* alloc::ffi::c_str::CString */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'typeid_out_wrapper';

-- src/typeid.rs:107
-- typeid::typeid::typeid_recv
CREATE  FUNCTION "typeid_recv"(
        "internal" internal /* pgrx::datum::internal::Internal */
) RETURNS TypeID /* typeid::typeid::TypeID */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'typeid_recv_wrapper';

-- src/typeid.rs:107
-- typeid::typeid::typeid_send
CREATE  FUNCTION "typeid_send"(
        "input" TypeID /* typeid::typeid::TypeID */
) RETURNS bytea /* alloc::vec::Vec<u8> */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'typeid_send_wrapper';


-- src/typeid.rs:107
-- typeid::typeid::TypeID
CREATE TYPE TypeID (
        INTERNALLENGTH = variable,
        INPUT = typeid_in, /* typeid::typeid::typeid_in */
        OUTPUT = typeid_out, /* typeid::typeid::typeid_out */
        RECEIVE = typeid_recv, /* typeid::typeid::typeid_recv */
        SEND = typeid_send, /* typeid::typeid::typeid_send */
        STORAGE = extended
);
/* </end connected objects> */

/* <begin connected objects> */
-- src/aggregate.rs:42
-- typeid::aggregate::type_id_max_type_id_max_combine
CREATE  FUNCTION "type_id_max_type_id_max_combine"(
        "this" TypeID, /* core::option::Option<typeid::typeid::TypeID> */
        "v" TypeID /* core::option::Option<typeid::typeid::TypeID> */
) RETURNS TypeID /* core::option::Option<typeid::typeid::TypeID> */
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'type_id_max_type_id_max_combine_wrapper';
/* </end connected objects> */

/* <begin connected objects> */
-- src/aggregate.rs:42
-- typeid::aggregate::type_id_max_type_id_max_state
CREATE  FUNCTION "type_id_max_type_id_max_state"(
        "this" TypeID, /* core::option::Option<typeid::typeid::TypeID> */
        "arg_one" TypeID /* typeid::typeid::TypeID */
) RETURNS TypeID /* core::option::Option<typeid::typeid::TypeID> */
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'type_id_max_type_id_max_state_wrapper';
/* </end connected objects> */

/* <begin connected objects> */
-- src/aggregate.rs:12
-- typeid::aggregate::type_id_min_type_id_min_combine
CREATE  FUNCTION "type_id_min_type_id_min_combine"(
        "this" TypeID, /* core::option::Option<typeid::typeid::TypeID> */
        "v" TypeID /* core::option::Option<typeid::typeid::TypeID> */
) RETURNS TypeID /* core::option::Option<typeid::typeid::TypeID> */
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'type_id_min_type_id_min_combine_wrapper';
/* </end connected objects> */

/* <begin connected objects> */
-- src/aggregate.rs:12
-- typeid::aggregate::type_id_min_type_id_min_state
CREATE  FUNCTION "type_id_min_type_id_min_state"(
        "this" TypeID, /* core::option::Option<typeid::typeid::TypeID> */
        "arg_one" TypeID /* typeid::typeid::TypeID */
) RETURNS TypeID /* core::option::Option<typeid::typeid::TypeID> */
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'type_id_min_type_id_min_state_wrapper';
/* </end connected objects> */

/* <begin connected objects> */
-- src/lib.rs:93
-- typeid::typeid_cmp
CREATE  FUNCTION "typeid_cmp"(
        "a" TypeID, /* typeid::typeid::TypeID */
        "b" TypeID /* typeid::typeid::TypeID */
) RETURNS INT /* i32 */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'typeid_cmp_wrapper';
/* </end connected objects> */

/* <begin connected objects> */
-- src/lib.rs:108
-- typeid::typeid_eq
CREATE  FUNCTION "typeid_eq"(
        "a" TypeID, /* typeid::typeid::TypeID */
        "b" TypeID /* typeid::typeid::TypeID */
) RETURNS bool /* bool */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'typeid_eq_wrapper';
/* </end connected objects> */

/* <begin connected objects> */
-- src/lib.rs:113
-- typeid::typeid_ge
CREATE  FUNCTION "typeid_ge"(
        "a" TypeID, /* typeid::typeid::TypeID */
        "b" TypeID /* typeid::typeid::TypeID */
) RETURNS bool /* bool */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'typeid_ge_wrapper';
/* </end connected objects> */

/* <begin connected objects> */
-- src/lib.rs:31
-- typeid::typeid_generate
CREATE  FUNCTION "typeid_generate"(
        "prefix" TEXT /* &str */
) RETURNS TypeID /* typeid::typeid::TypeID */
STRICT VOLATILE PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'typeid_generate_wrapper';
/* </end connected objects> */

/* <begin connected objects> */
-- src/lib.rs:521
-- typeid::typeid_generate_batch
CREATE  FUNCTION "typeid_generate_batch"(
        "prefix" TEXT, /* &str */
        "count" INT /* i32 */
) RETURNS TypeID[] /* alloc::vec::Vec<typeid::typeid::TypeID> */
STRICT VOLATILE PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'typeid_generate_batch_wrapper';
/* </end connected objects> */

/* <begin connected objects> */
-- src/lib.rs:48
-- typeid::typeid_generate_nil
CREATE  FUNCTION "typeid_generate_nil"() RETURNS TypeID /* typeid::typeid::TypeID */
STRICT VOLATILE PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'typeid_generate_nil_wrapper';
/* </end connected objects> */

/* <begin connected objects> */
-- src/lib.rs:118
-- typeid::typeid_gt
CREATE  FUNCTION "typeid_gt"(
        "a" TypeID, /* typeid::typeid::TypeID */
        "b" TypeID /* typeid::typeid::TypeID */
) RETURNS bool /* bool */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'typeid_gt_wrapper';
/* </end connected objects> */

/* <begin connected objects> */
-- src/lib.rs:497
-- typeid::typeid_has_prefix
CREATE  FUNCTION "typeid_has_prefix"(
        "typeid" TypeID, /* typeid::typeid::TypeID */
        "prefix" TEXT /* &str */
) RETURNS bool /* bool */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'typeid_has_prefix_wrapper';
/* </end connected objects> */

/* <begin connected objects> */
-- src/lib.rs:129
-- typeid::typeid_hash
CREATE  FUNCTION "typeid_hash"(
        "typeid" TypeID /* typeid::typeid::TypeID */
) RETURNS INT /* i32 */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'typeid_hash_wrapper';
/* </end connected objects> */

/* <begin connected objects> */
-- src/lib.rs:136
-- typeid::typeid_hash_extended
CREATE  FUNCTION "typeid_hash_extended"(
        "typeid" TypeID, /* typeid::typeid::TypeID */
        "seed" bigint /* i64 */
) RETURNS bigint /* i64 */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'typeid_hash_extended_wrapper';
/* </end connected objects> */

/* <begin connected objects> */
-- src/lib.rs:509
-- typeid::typeid_is_nil_prefix
CREATE  FUNCTION "typeid_is_nil_prefix"(
        "typeid" TypeID /* typeid::typeid::TypeID */
) RETURNS bool /* bool */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'typeid_is_nil_prefix_wrapper';
/* </end connected objects> */

/* <begin connected objects> */
-- src/lib.rs:60
-- typeid::typeid_is_valid
CREATE  FUNCTION "typeid_is_valid"(
        "input" TEXT /* &str */
) RETURNS bool /* bool */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'typeid_is_valid_wrapper';
/* </end connected objects> */

/* <begin connected objects> */
-- src/lib.rs:103
-- typeid::typeid_le
CREATE  FUNCTION "typeid_le"(
        "a" TypeID, /* typeid::typeid::TypeID */
        "b" TypeID /* typeid::typeid::TypeID */
) RETURNS bool /* bool */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'typeid_le_wrapper';
/* </end connected objects> */

/* <begin connected objects> */
-- src/lib.rs:98
-- typeid::typeid_lt
CREATE  FUNCTION "typeid_lt"(
        "a" TypeID, /* typeid::typeid::TypeID */
        "b" TypeID /* typeid::typeid::TypeID */
) RETURNS bool /* bool */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'typeid_lt_wrapper';
/* </end connected objects> */

/* <begin connected objects> */
-- src/lib.rs:123
-- typeid::typeid_ne
CREATE  FUNCTION "typeid_ne"(
        "a" TypeID, /* typeid::typeid::TypeID */
        "b" TypeID /* typeid::typeid::TypeID */
) RETURNS bool /* bool */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'typeid_ne_wrapper';
/* </end connected objects> */

/* <begin connected objects> */
-- src/lib.rs:66
-- typeid::typeid_prefix
CREATE  FUNCTION "typeid_prefix"(
        "typeid" TypeID /* typeid::typeid::TypeID */
) RETURNS TEXT /* alloc::string::String */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'typeid_prefix_wrapper';
/* </end connected objects> */

/* <begin connected objects> */
-- src/lib.rs:72
-- typeid::typeid_to_uuid
CREATE  FUNCTION "typeid_to_uuid"(
        "typeid" TypeID /* typeid::typeid::TypeID */
) RETURNS uuid /* pgrx::datum::uuid::Uuid */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'typeid_to_uuid_wrapper';
/* </end connected objects> */

/* <begin connected objects> */
-- src/lib.rs:144
-- typeid::typeid_uuid_generate_v7
CREATE  FUNCTION "typeid_uuid_generate_v7"() RETURNS uuid /* pgrx::datum::uuid::Uuid */
STRICT
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'typeid_uuid_generate_v7_wrapper';
/* </end connected objects> */

/* <begin connected objects> */
-- src/lib.rs:77
-- typeid::uuid_to_typeid
CREATE  FUNCTION "uuid_to_typeid"(
        "prefix" TEXT, /* &str */
        "uuid" uuid /* pgrx::datum::uuid::Uuid */
) RETURNS TypeID /* typeid::typeid::TypeID */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'uuid_to_typeid_wrapper';
/* </end connected objects> */

/* <begin connected objects> */
-- src/aggregate.rs:42
-- typeid::aggregate::TypeIDMax
CREATE AGGREGATE max (
        TypeID /* typeid::typeid::TypeID */
)
(
        SFUNC = "type_id_max_type_id_max_state", /* typeid::aggregate::TypeIDMax::state */
        STYPE = TypeID, /* core::option::Option<typeid::typeid::TypeID> */
        COMBINEFUNC = "type_id_max_type_id_max_combine", /* typeid::aggregate::TypeIDMax::combine */
        PARALLEL = SAFE /* typeid::aggregate::TypeIDMax::PARALLEL */
);
/* </end connected objects> */

/* <begin connected objects> */
-- src/aggregate.rs:12
-- typeid::aggregate::TypeIDMin
CREATE AGGREGATE min (
        TypeID /* typeid::typeid::TypeID */
)
(
        SFUNC = "type_id_min_type_id_min_state", /* typeid::aggregate::TypeIDMin::state */
        STYPE = TypeID, /* core::option::Option<typeid::typeid::TypeID> */
        COMBINEFUNC = "type_id_min_type_id_min_combine", /* typeid::aggregate::TypeIDMin::combine */
        PARALLEL = SAFE /* typeid::aggregate::TypeIDMin::PARALLEL */
);
/* </end connected objects> */

/* <begin connected objects> */
-- src/lib.rs:149
-- finalize

/* ──────────────────────────────────────────────────────────────
 * Implicit cast: text → typeid
 *   Allows:     SELECT 'user_01h…' = id;
 *   Context:    IMPLICIT  (works everywhere a typeid is expected)
 *   Safety:     relies on typeid_in for validation; bad literals
 *               still fail with ERROR.
 * ──────────────────────────────────────────────────────────────*/
CREATE CAST (text AS typeid)
    WITH INOUT
    AS IMPLICIT;

/* ──────────────────────────────────────────────────────────────
 * Additional utility functions for better SQL integration
 * ──────────────────────────────────────────────────────────────*/

-- Create an operator for prefix matching to enable efficient queries
CREATE OPERATOR @> (
    LEFTARG = typeid,
    RIGHTARG = text,
    PROCEDURE = typeid_has_prefix,
    COMMUTATOR = '@<'
);

-- Create a functional index helper for prefix-based queries
-- Usage: CREATE INDEX idx_user_ids ON users (typeid_prefix(id)) WHERE typeid_has_prefix(id, 'user');
COMMENT ON FUNCTION typeid_prefix(typeid) IS 'Extract the prefix from a TypeID for indexing and filtering';
COMMENT ON FUNCTION typeid_has_prefix(typeid, text) IS 'Check if TypeID has a specific prefix - useful for filtering';
COMMENT ON FUNCTION typeid_is_valid(text) IS 'Validate TypeID format without parsing - useful for constraints';
COMMENT ON FUNCTION typeid_generate_nil() IS 'Generate TypeID with empty prefix (UUID-only format)';

   CREATE OPERATOR < (
        LEFTARG = typeid,
        RIGHTARG = typeid,
        PROCEDURE = typeid_lt
    );

    CREATE OPERATOR <= (
        LEFTARG = typeid,
        RIGHTARG = typeid,
        PROCEDURE = typeid_le
    );

    CREATE OPERATOR = (
        LEFTARG = typeid,
        RIGHTARG = typeid,
        PROCEDURE = typeid_eq,
        COMMUTATOR = '=',
        NEGATOR = '<>',
        HASHES,
        MERGES
    );

    CREATE OPERATOR >= (
        LEFTARG = typeid,
        RIGHTARG = typeid,
        PROCEDURE = typeid_ge
    );

    CREATE OPERATOR > (
        LEFTARG = typeid,
        RIGHTARG = typeid,
        PROCEDURE = typeid_gt
    );

    CREATE OPERATOR <> (
        LEFTARG = typeid,
        RIGHTARG = typeid,
        PROCEDURE = typeid_ne
    );

    CREATE OPERATOR CLASS typeid_ops DEFAULT FOR TYPE typeid USING btree AS
        OPERATOR 1 < (typeid, typeid),
        OPERATOR 2 <= (typeid, typeid),
        OPERATOR 3 = (typeid, typeid),
        OPERATOR 4 >= (typeid, typeid),
        OPERATOR 5 > (typeid, typeid),
        FUNCTION 1 typeid_cmp(typeid, typeid);

        CREATE OPERATOR FAMILY typeid_hash_ops USING hash;

        CREATE OPERATOR CLASS typeid_hash_ops DEFAULT FOR TYPE typeid USING hash AS
            OPERATOR 1 = (typeid, typeid),
            FUNCTION 1 typeid_hash(typeid),
            FUNCTION 2 typeid_hash_extended(typeid, bigint);
/* </end connected objects> */