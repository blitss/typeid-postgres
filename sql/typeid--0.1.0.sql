/* 
This file is auto generated by pgrx.

The ordering of items is not stable, it is driven by a dependency graph.
*/

-- src/lib.rs:147
-- typeid::typeid_uuid_generate_v7
CREATE  FUNCTION "typeid_uuid_generate_v7"() RETURNS uuid /* pgrx::datum::uuid::Uuid */
STRICT
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'typeid_uuid_generate_v7_wrapper';

-- src/typeid.rs:76
-- typeid::typeid::TypeID
CREATE TYPE TypeID;

-- src/typeid.rs:76
-- typeid::typeid::typeid_in
CREATE  FUNCTION "typeid_in"(
	"input" cstring /* core::option::Option<&core::ffi::c_str::CStr> */
) RETURNS TypeID /* core::option::Option<typeid::typeid::TypeID> */
IMMUTABLE PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'typeid_in_wrapper';

-- src/typeid.rs:76
-- typeid::typeid::typeid_out
CREATE  FUNCTION "typeid_out"(
	"input" TypeID /* typeid::typeid::TypeID */
) RETURNS cstring /* &core::ffi::c_str::CStr */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'typeid_out_wrapper';

-- src/typeid.rs:76
-- typeid::typeid::TypeID
CREATE TYPE TypeID (
	INTERNALLENGTH = variable,
	INPUT = typeid_in, /* typeid::typeid::typeid_in */
	OUTPUT = typeid_out, /* typeid::typeid::typeid_out */
	STORAGE = extended
);

-- src/lib.rs:27
-- typeid::uuid_to_typeid
CREATE  FUNCTION "uuid_to_typeid"(
	"prefix" TEXT, /* &str */
	"uuid" uuid /* pgrx::datum::uuid::Uuid */
) RETURNS TypeID /* typeid::typeid::TypeID */
STRICT
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'uuid_to_typeid_wrapper';

-- src/lib.rs:45
-- typeid::typeid_le
CREATE  FUNCTION "typeid_le"(
	"a" TypeID, /* typeid::typeid::TypeID */
	"b" TypeID /* typeid::typeid::TypeID */
) RETURNS bool /* bool */
STRICT
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'typeid_le_wrapper';

-- src/lib.rs:60
-- typeid::typeid_gt
CREATE  FUNCTION "typeid_gt"(
	"a" TypeID, /* typeid::typeid::TypeID */
	"b" TypeID /* typeid::typeid::TypeID */
) RETURNS bool /* bool */
STRICT
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'typeid_gt_wrapper';

-- src/lib.rs:17
-- typeid::typeid_generate
CREATE  FUNCTION "typeid_generate"(
	"prefix" TEXT /* &str */
) RETURNS TypeID /* typeid::typeid::TypeID */
STRICT
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'typeid_generate_wrapper';

-- src/lib.rs:40
-- typeid::typeid_lt
CREATE  FUNCTION "typeid_lt"(
	"a" TypeID, /* typeid::typeid::TypeID */
	"b" TypeID /* typeid::typeid::TypeID */
) RETURNS bool /* bool */
STRICT
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'typeid_lt_wrapper';

-- src/lib.rs:55
-- typeid::typeid_ge
CREATE  FUNCTION "typeid_ge"(
	"a" TypeID, /* typeid::typeid::TypeID */
	"b" TypeID /* typeid::typeid::TypeID */
) RETURNS bool /* bool */
STRICT
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'typeid_ge_wrapper';

-- src/aggregate.rs:26
-- typeid::aggregate::type_id_max_state
CREATE  FUNCTION "type_id_max_state"(
	"this" TypeID, /* core::option::Option<typeid::typeid::TypeID> */
	"arg_one" TypeID /* typeid::typeid::TypeID */
) RETURNS TypeID /* core::option::Option<typeid::typeid::TypeID> */
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'type_id_max_state_wrapper';

-- src/aggregate.rs:26
-- typeid::aggregate::TypeIDMax
CREATE AGGREGATE max (
	TypeID /* typeid::typeid::TypeID */
)
(
	SFUNC = "type_id_max_state", /* typeid::aggregate::TypeIDMax::state */
	STYPE = TypeID /* core::option::Option<typeid::typeid::TypeID> */
);

-- src/lib.rs:70
-- typeid::typeid_hash
CREATE  FUNCTION "typeid_hash"(
	"typeid" TypeID /* typeid::typeid::TypeID */
) RETURNS INT /* i32 */
STRICT
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'typeid_hash_wrapper';

-- src/lib.rs:22
-- typeid::typeid_to_uuid
CREATE  FUNCTION "typeid_to_uuid"(
	"typeid" TypeID /* typeid::typeid::TypeID */
) RETURNS uuid /* pgrx::datum::uuid::Uuid */
STRICT
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'typeid_to_uuid_wrapper';

-- src/aggregate.rs:8
-- typeid::aggregate::type_id_min_state
CREATE  FUNCTION "type_id_min_state"(
	"this" TypeID, /* core::option::Option<typeid::typeid::TypeID> */
	"arg_one" TypeID /* typeid::typeid::TypeID */
) RETURNS TypeID /* core::option::Option<typeid::typeid::TypeID> */
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'type_id_min_state_wrapper';

-- src/aggregate.rs:8
-- typeid::aggregate::TypeIDMin
CREATE AGGREGATE min (
	TypeID /* typeid::typeid::TypeID */
)
(
	SFUNC = "type_id_min_state", /* typeid::aggregate::TypeIDMin::state */
	STYPE = TypeID /* core::option::Option<typeid::typeid::TypeID> */
);

-- src/lib.rs:65
-- typeid::typeid_ne
CREATE  FUNCTION "typeid_ne"(
	"a" TypeID, /* typeid::typeid::TypeID */
	"b" TypeID /* typeid::typeid::TypeID */
) RETURNS bool /* bool */
STRICT
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'typeid_ne_wrapper';

-- src/lib.rs:77
-- typeid::typeid_hash_extended
CREATE  FUNCTION "typeid_hash_extended"(
	"typeid" TypeID, /* typeid::typeid::TypeID */
	"seed" bigint /* i64 */
) RETURNS bigint /* i64 */
STRICT
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'typeid_hash_extended_wrapper';

-- src/lib.rs:35
-- typeid::typeid_cmp
CREATE  FUNCTION "typeid_cmp"(
	"a" TypeID, /* typeid::typeid::TypeID */
	"b" TypeID /* typeid::typeid::TypeID */
) RETURNS INT /* i32 */
STRICT
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'typeid_cmp_wrapper';

-- src/lib.rs:50
-- typeid::typeid_eq
CREATE  FUNCTION "typeid_eq"(
	"a" TypeID, /* typeid::typeid::TypeID */
	"b" TypeID /* typeid::typeid::TypeID */
) RETURNS bool /* bool */
STRICT
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'typeid_eq_wrapper';

-- src/lib.rs:84
-- finalize

   CREATE OPERATOR < (
        LEFTARG = typeid,
        RIGHTARG = typeid,
        PROCEDURE = typeid_lt
    );

    CREATE OPERATOR <= (
        LEFTARG = typeid,
        RIGHTARG = typeid,
        PROCEDURE = typeid_le
    );

    CREATE OPERATOR = (
        LEFTARG = typeid,
        RIGHTARG = typeid,
        PROCEDURE = typeid_eq,
        COMMUTATOR = '=',
        NEGATOR = '<>',
        HASHES,
        MERGES
    );

    CREATE OPERATOR >= (
        LEFTARG = typeid,
        RIGHTARG = typeid,
        PROCEDURE = typeid_ge
    );

    CREATE OPERATOR > (
        LEFTARG = typeid,
        RIGHTARG = typeid,
        PROCEDURE = typeid_gt
    );

    CREATE OPERATOR <> (
        LEFTARG = typeid,
        RIGHTARG = typeid,
        PROCEDURE = typeid_ne
    );

    CREATE OPERATOR CLASS typeid_ops DEFAULT FOR TYPE typeid USING btree AS
        OPERATOR 1 < (typeid, typeid),
        OPERATOR 2 <= (typeid, typeid),
        OPERATOR 3 = (typeid, typeid),
        OPERATOR 4 >= (typeid, typeid),
        OPERATOR 5 > (typeid, typeid),
        FUNCTION 1 typeid_cmp(typeid, typeid);

        CREATE OPERATOR FAMILY typeid_hash_ops USING hash;

        CREATE OPERATOR CLASS typeid_hash_ops DEFAULT FOR TYPE typeid USING hash AS
            OPERATOR 1 = (typeid, typeid),
            FUNCTION 1 typeid_hash(typeid),
            FUNCTION 2 typeid_hash_extended(typeid, bigint);
    
